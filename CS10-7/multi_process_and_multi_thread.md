# 📖 용어 정리
- 프로그램  
    - 어떤 작업을 위해 운영체제 위에서 실행할 수 있는 파일
    - 하드디스크 같은 저장장치에 보관되어 있다가 마우스로 더블클릭하면 실행된다.
- 프로세스
    - 운영 체제 위에서 **실행 중**인 프로그램
    - 컴퓨터 시스템의 작업 단위로 테스크(task)라고도 부른다.
    - 프로그램 명령어와 데이터들이 메모리에 올라오고 실행 중 또는 실행 대기 중인 상태
    - 폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행된다는 의미이다.

👉 프로그램은 저장장치에 저장되있는 정적 상태, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다.  

- 프로세서  
    - 프로세스가 동작될 수 있도록 하는 하드웨어(**CPU**)  
    - 프로그램의 자원들이 메모리에 올라오고, 실행되어야 할 코드의 메모리 주소를 CPU의 레지스터로 올려준다.  
- 코어  
    - 코어란 각종 연산을 하는 CPU의 핵심요소이며, CPU 내부에는 코어 말고도 컨트롤러, 캐시 메모리 등이 들어있다.  
    - CPU 안에서 일하는 부품 중 가장 중요한 역할이다.  
    - 코어가 많을수록 일을 처리하는 사람이 많아지는 것이기 때문에 많으면 많을수록 처리속도가 빨라진다.  
<br>
<br>

# 멀티 프로세스
## 일괄 처리 방식
- 일괄 처리 방식은 프로세스 A, B, C가 있으면 A가 시작하고 끝날 때 B를 시작, B가 끝나면 C가 시작하는 식의 처리 방식이였다.
- 그러나 보다시피 이런 처리 방식은 실행해야 할 프로세스들이 남아있지만 A가 끝날 때까지 CPU가 놀고 있게 되어 매우 효율적이지 못하다.

## 시분할 방식
- 앞의 일괄 처리 방식의 효율성을 높이기 위해 시분할 방식이 나오게 되었다.
- 시분할 방식은 하나의 CPU가 프로세스 A, B, C를 일정한 시간 돌아가면서 하나씩 진행하는 것이다.
- A - (1초 뒤) -> B - (1초 뒤) -> C -(1초 뒤) -> A  
<br>

## 프로세스 제어 블록(PCB - Process Control Block)
- 프로그램을 실행하면 메모리의 적당한 위치로 가져온다.
- 그와 동시에 작업 지시서인 PCB를 만든다.
- 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 고유한 PCB를 받았다는 뜻이다.
- PCB는 프로세스 생성 시 만들어져 프로세스가 종료되면 폐기된다.  
<br>

## 프로세스 제어 블록의 구성
### 포인터
- 프로세스의 현재 위치를 저장한다.
### 프로세스 상태
- 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated), 보류 준비, 보류 대기 등의 프로세스 상태를 저장한다.
### 프로세스 구분자(PID - Process IDentification)
- 프로세스들마다 가지는 고유의 일련번호로 프로세스들을 구분하기 위해 사용된다.
### 프로그램 카운터
- 다음에 실행될 명령어의 위치를 저장한다.
### 프로세스 우선 순위
- 프로세스의 중요도는 각각 다르다. 사용자 프로세스보다 중요도가 큰 커널 프로세스는 우선 순위가 높고, 사용자 프로세스끼리도 우선 순위가 다르다.
- 다양한 우선 순위의 프로세스가 대기 상태로 들어오기 때문에 대기 상태의 큐도 우선 순위별로 따로 운영된다.
- CPU 스케줄러가 준비 상태의 프로세스를 실행 상태로 올길 때 프로세스의 우선 순위를 기준으로 삼는다. 따라서 높은 우선 순위의 프로세스는 먼저, 더 자주 실행된다.
### 각종 레지스터 정보
- PCB에는 프로세스가 실행되는 중에 사용하던 레지스터, 누산기, 색인 레지스터, 스택 포인터와 같은 레지스터의 값이 저장된다.
### 메모리 관리 정보
- 프로세스의 메모리 위치
- 메모리 보호를 위한 경계 레지스터와 한계 레지스터
### 할당된 자원 정보
- 프로세스를 실행하기 위해 사용하은 입출력 자원이나 오픈 파일 등에 대한 정보를 저장한다.
### 계정 정보
- 계정 정보, CPU 할당 시간, CPU 사용 시간 등을 저장한다.
### 부모 프로세스 구분자와 자식 프로세스 구분자
- 부모 프로세스를 가리키는 PPID와 자식 프로세스를 가리키는 CPID를 저장한다.
  
<br>
<br>
운영체제는 빠르게 PCB에 접근하기 위해 프로세스 테이블을 사용하여 각 프로세스의 PCB를 관리한다.  
<br>
<br>
<img width="600" src="https://user-images.githubusercontent.com/17706346/152643516-b8d7b600-7543-4fce-99b6-25f0534cf12c.png">  
<br>
<br>
<br>

## 프로세스의 상태
시분할 시스템에서는 CPU를 얻어 실행 중이 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하다.  
앞서 말했듯이, 일괄 처리 방식이 한 손님의 코스 요리를 전체 만들고 다음 손님을 만든다면,  
시분할 시스템은 손님들의 코스 요리에 단품을 하나씩 돌아가며 요리하기 때문이다.  
때문에 CPU를 차지하고 있는 상태, 자신의 차례를 기다리고 있는 등 여러 상태가 있다.  
<br>

### 생성 상태(create status)
- 프로세스가 메모리에 올라와 실행 준비를 완료한 상태이다.
- PCB가 생성된다.

### 준비 상태(ready status)
- 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태이다.
- CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 순서가 될 떄까지 준비 상태에서 기다려야 한다.
- 대기 목록에 들어가 있다.

### 실행 상태(running status)
- 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태이다.
- execute status라고 하기도 한다.
- 일정 시간(타임 슬라이스 또는 타임 퀀텀)동안 CPU를 사용할 권리를 갖는다.
- 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 준비 상태로 돌아와 다음 차례를 기다린다. 이를 타임 아웃이라 한다.
- 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다 갔다 한다.

### 대기 상태(blocking status)
- 입출력을 요구로 하는 프로세스의 경우 입출력이 완료될 떄까지 기다리는 상태이다.
- 작업의 효율성을 높이기 위해 실행된 프로세스가 입출력이 들어올 때까지 기다리게 두지 않고 대기 상태로 옮기는 것이다.
- 대기 상태로 옮겨지면 준비 상태에 프로세스를 가져와 실행시키고, 대기 상태에 있던 프로세스는 입출력이 완료된 후 다시 준비 상태로 들어가 자신의 순서를 기다리게 된다.

### 완료 상태(terminate status)
- 실행 상태에서 주어진 작업을 마치면 완료 상태로 진입한다.
- 완료 상태에서 PCB가 사라진다.  

### 휴식 상태(pause status)
- 프로세스가 작업을 일시적으로 쉬고 있는 상태.

### 보류 상태(suspend status)
- 프로세스가 메모리에서 잠시 쫓겨난 상태
    - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
    - 프로그램에 오류가 있어서 실행을 미루어야 할 때
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
<br>

## CPU 스케쥴러
- 준비 상태의 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일을 한다. 
- 대기 목록에 맨 앞의 프로세스 중 하나를 골라 실행 상태로 바꾸어주는 작업을 디스패치(dispatch)라고 한다.
- 새로운 프로세스가 들어오면 일정 시간이 지난 뒤 알려달라고 클록에 요청한다.  

<img width="600" src="https://user-images.githubusercontent.com/17706346/152650090-4e2119d1-625d-4844-8a44-9488d0e48575.png">
<br>
<br>

# 문맥 교환(Context Switching)
디스패치 작업이 이루어지면서 기존의 실행 상태에 있던 프로세스의 PCB에 지금까지 작업 내용을 저장하고 나가게 된다.  
그리고 교체된 프로세스의 PCB내용으로 CPU가 다시 세팅된다.  
이와 같이 두 프로세스의 PCB를 교환하는 작업을 컨텍스트 스위칭이라 한다.  
<br>
<img width="600" src="https://user-images.githubusercontent.com/17706346/152650323-0b4ea71e-8fd4-4f6a-abbc-6ad3d3f49af8.png">  
<br>

## 문맥 교환이 발생하는 경우
- 타임 아웃
    - 실행 상태의 프로세스가 주어진 시간을 다 사용할 때
- 인터럽트
    - 실행 상태의 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할 때
    - 현재 실행 상태의 PCB를 저장하고 인터럽트 관리 프로세스를 실행 상태로 만든다.
    - 인터럽트 관리 프로세스는 메모리 범위를 넘어선 프로세스를 강제 종료하고 인터럽트 처리를 마친다.
<br>
<br>

# 스레드
프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고,  
스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.  
<br>
<br>

# 🧐 멀티 태스킹이란?
CPU는 **한순간에 하나의 프로세스**만 실행할 수 있다.  
그러나 운영체제가 짧은 시간에 수십번에서 수천번 실행할 프로세스를 **교체**하고 있기 때문에  
우리는 동시에 여려 개의 작업이 실행되고 있다고 느끼는 것이다.  
이런 교체 과정을 컨텍스트 스위칭이라고 한다.
<br>
<br>

# 🧐 멀티 스레드란?
// TODO
<br>
<br>